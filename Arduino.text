/*
  ADXL335 Lab - Single Sketch with MODE switch (Lab-instruction compliant fixes)

  What was fixed (without violating lab requirements):
  - MODE 4: Added input smoothing (low-pass filter) BEFORE the angle formula to reduce jitter
    while still using atan2(), sqrt(), pow(), and (180/PI) as the lab specifies.
  - MODE 2: Removed extra Serial prints (optional debug) to better preserve ~2 ms sampling intent.
  - MODE 1/2/3/4 timing remains per lab: ~1 ms, ~2 ms, ~2 ms, 100 ms.

  Modes:
    1 = Part 1: Vibration (prints Ax Ay Az in g) every ~1 ms (Serial Plotter friendly)
    2 = Part 2a: Collision detect (if/else) sample every ~2 ms, blink LED for 3 s on hit
    3 = Part 2b: Collision detect (while) sample every ~2 ms, blink LED for 3 s on hit
    4 = Part 3/4: Angles (prints angleX,angleY,angleZ CSV) every 100 ms (for GitHub page)

  How to change MODE:
    - In Serial Monitor, set "No line ending"
    - Send a single digit: 1,2,3,4 then press Send
*/

#include <math.h>

// ---------- Pins ----------
const int PIN_X = A0;
const int PIN_Y = A1;
const int PIN_Z = A2;
const int LED_PIN = LED_BUILTIN;

// ---------- Accelerometer constants ----------
const float VREF = 5.0;         // UNO default analog reference
const float ADC_MAX = 1023.0;
float V0G = 1.65;               // nominal 0g voltage (can be calibrated)
const float SENS = 0.33;        // V/g (330 mV/g)

// ---------- Part 2 threshold ----------
const float THRESH_G = 2.8;

// ---------- Mode ----------
volatile int MODE = 4;          // default to angles for Part 4

// ---------- MODE 4 smoothing (lab-compliant) ----------
// We smooth Ax/Ay/Az, then use the SAME angle equations with atan2/sqrt/pow and (180/PI).
// Smaller ALPHA => smoother (less jitter) but more lag.
const float ALPHA = 0.12f;      // try 0.08â€“0.20
static float fax = 0.0f;
static float fay = 0.0f;
static float faz = 0.0f;
static bool filterInit = false;

// ---------- Helpers ----------
static inline float adcToG(int adc) {
  float v = (adc * VREF) / ADC_MAX;
  return (v - V0G) / SENS;
}
static inline float absf(float x) { return x < 0 ? -x : x; }

static inline void blinkForMs(unsigned long durationMs) {
  unsigned long start = millis();
  while (millis() - start < durationMs) {
    digitalWrite(LED_PIN, HIGH); delay(100);
    digitalWrite(LED_PIN, LOW);  delay(100);
  }
}

static inline bool collisionDetected(float ax, float ay, float az) {
  return (absf(ax) > THRESH_G) || (absf(ay) > THRESH_G) || (absf(az) > THRESH_G);
}

void readModeFromSerial() {
  while (Serial.available() > 0) {
    char c = (char)Serial.read();
    if (c >= '1' && c <= '4') {
      MODE = c - '0';
      Serial.print("MODE set to ");
      Serial.println(MODE);

      // Re-init filter when switching into MODE 4 so the first output doesn't "ramp"
      if (MODE == 4) filterInit = false;
    }
  }
}

void setup() {
  pinMode(LED_PIN, OUTPUT);
  Serial.begin(115200);

  Serial.println("ADXL335 Lab Single Sketch");
  Serial.println("Send 1,2,3,4 in Serial Monitor to change mode.");
  Serial.println("1=Vibration(g)  2=Collision(if)  3=Collision(while)  4=Angles(CSV)");
}

void loop() {
  readModeFromSerial();

  // Read raw once per loop (each mode controls its own timing)
  int ax_adc = analogRead(PIN_X);
  int ay_adc = analogRead(PIN_Y);
  int az_adc = analogRead(PIN_Z);

  float ax = adcToG(ax_adc);
  float ay = adcToG(ay_adc);
  float az = adcToG(az_adc);

  if (MODE == 1) {
    // Part 1: vibration measurement (Serial Plotter)
    Serial.print(ax, 3); Serial.print(' ');
    Serial.print(ay, 3); Serial.print(' ');
    Serial.println(az, 3);
    delayMicroseconds(1000); // ~1 ms
    return;
  }

  if (MODE == 2) {
    // Part 2a: collision detection using if/else
    bool hit = collisionDetected(ax, ay, az);
    if (hit) {
      blinkForMs(3000);
    } else {
      // do nothing
    }
    delayMicroseconds(2000); // ~2 ms
    return;
  }

  if (MODE == 3) {
    // Part 2b: collision detection using while
    if (collisionDetected(ax, ay, az)) {
      unsigned long start = millis();
      while (millis() - start < 3000UL) {
        digitalWrite(LED_PIN, HIGH); delay(100);
        digitalWrite(LED_PIN, LOW);  delay(100);
      }
    }
    delayMicroseconds(2000); // ~2 ms
    return;
  }

  // MODE == 4 (default): Part 3/4 angles (CSV for GitHub page)

  // --- Lab-compliant smoothing on acceleration inputs ---
  // Initialize filter with the first sample to avoid a ramp from 0.
  if (!filterInit) {
    fax = ax; fay = ay; faz = az;
    filterInit = true;
  } else {
    fax = (1.0f - ALPHA) * fax + ALPHA * ax;
    fay = (1.0f - ALPHA) * fay + ALPHA * ay;
    faz = (1.0f - ALPHA) * faz + ALPHA * az;
  }

  // --- SAME lab-style formula requirements: atan2(), sqrt(), pow(), (180/PI) ---
  float angleX = atan2(fax, sqrt(pow(fay, 2) + pow(faz, 2))) * (180.0 / PI);
  float angleY = atan2(fay, sqrt(pow(fax, 2) + pow(faz, 2))) * (180.0 / PI);
  float angleZ = atan2(faz, sqrt(pow(fax, 2) + pow(fay, 2))) * (180.0 / PI);

  // CSV only: angleX,angleY,angleZ
  Serial.print(angleX, 2); Serial.print(',');
  Serial.print(angleY, 2); Serial.print(',');
  Serial.println(angleZ, 2);

  delay(100); // 100 ms (lab requirement)
}
