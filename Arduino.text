/*
  ADXL335 Lab - Single Sketch with MODE switch
  Modes:
    1 = Part 1: Vibration (prints Ax Ay Az in g) every 1 ms (Serial Plotter friendly)
    2 = Part 2a: Collision detect (if/else) sample every 2 ms, blink LED for 3 s on hit
    3 = Part 2b: Collision detect (while) sample every 2 ms, blink LED for 3 s on hit
    4 = Part 3/4: Angles (prints angleX,angleY,angleZ CSV) every 100 ms (for GitHub page)

  How to change MODE:
    - In Serial Monitor, set "No line ending"
    - Send a single digit: 1,2,3,4 then press Send
*/

#include <math.h>

// ---------- Pins ----------
const int PIN_X = A0;
const int PIN_Y = A1;
const int PIN_Z = A2;
const int LED_PIN = LED_BUILTIN;

// ---------- Accelerometer constants ----------
const float VREF = 5.0;         // UNO default analog reference
const float ADC_MAX = 1023.0;
float V0G = 1.65;               // nominal 0g voltage
const float SENS = 0.33;        // V/g (330 mV/g)

// ---------- Part 2 threshold ----------
const float THRESH_G = 2.8;

// ---------- Mode ----------
volatile int MODE = 4;          // default to angles for Part 4

// ---------- Helpers ----------
static inline float adcToG(int adc) {
  float v = (adc * VREF) / ADC_MAX;
  return (v - V0G) / SENS;
}
static inline float absf(float x) { return x < 0 ? -x : x; }

static inline void blinkForMs(unsigned long durationMs) {
  unsigned long start = millis();
  while (millis() - start < durationMs) {
    digitalWrite(LED_PIN, HIGH); delay(100);
    digitalWrite(LED_PIN, LOW);  delay(100);
  }
}

static inline bool collisionDetected(float ax, float ay, float az) {
  return (absf(ax) > THRESH_G) || (absf(ay) > THRESH_G) || (absf(az) > THRESH_G);
}

void readModeFromSerial() {
  while (Serial.available() > 0) {
    char c = (char)Serial.read();
    if (c >= '1' && c <= '4') {
      MODE = c - '0';
      Serial.print("MODE set to ");
      Serial.println(MODE);
    }
  }
}

void setup() {
  pinMode(LED_PIN, OUTPUT);
  Serial.begin(115200);

  Serial.println("ADXL335 Lab Single Sketch");
  Serial.println("Send 1,2,3,4 in Serial Monitor to change mode.");
  Serial.println("1=Vibration(g)  2=Collision(if)  3=Collision(while)  4=Angles(CSV)");
}

void loop() {
  readModeFromSerial();

  // Read raw once per loop (each mode controls its own timing)
  int ax_adc = analogRead(PIN_X);
  int ay_adc = analogRead(PIN_Y);
  int az_adc = analogRead(PIN_Z);

  float ax = adcToG(ax_adc);
  float ay = adcToG(ay_adc);
  float az = adcToG(az_adc);

  if (MODE == 1) {
    // Part 1: vibration measurement (Serial Plotter)
    Serial.print(ax, 3); Serial.print(' ');
    Serial.print(ay, 3); Serial.print(' ');
    Serial.println(az, 3);
    delayMicroseconds(1000); // 1 ms
    return;
  }

  if (MODE == 2) {
    // Part 2a: collision detection using if/else
    bool hit = collisionDetected(ax, ay, az);
    if (hit) {
      blinkForMs(3000);
    } else {
      // do nothing
    }
    // optional debug output
    Serial.print(ax, 3); Serial.print(' ');
    Serial.print(ay, 3); Serial.print(' ');
    Serial.println(az, 3);
    delayMicroseconds(2000); // 2 ms
    return;
  }

  if (MODE == 3) {
    // Part 2b: collision detection using while
    if (collisionDetected(ax, ay, az)) {
      unsigned long start = millis();
      while (millis() - start < 3000UL) {
        digitalWrite(LED_PIN, HIGH); delay(100);
        digitalWrite(LED_PIN, LOW);  delay(100);
      }
    }
    delayMicroseconds(2000); // 2 ms
    return;
  }

  // MODE == 4 (default): Part 3/4 angles (CSV for GitHub page)
  float angleX = atan2(ax, sqrt(pow(ay, 2) + pow(az, 2))) * (180.0 / PI);
  float angleY = atan2(ay, sqrt(pow(ax, 2) + pow(az, 2))) * (180.0 / PI);
  float angleZ = atan2(az, sqrt(pow(ax, 2) + pow(ay, 2))) * (180.0 / PI);

  // CSV only: angleX,angleY,angleZ
  Serial.print(angleX, 2); Serial.print(',');
  Serial.print(angleY, 2); Serial.print(',');
  Serial.println(angleZ, 2);

  delay(100); // 100 ms
}
